# 算法学习笔记
## 数据类型
1. **数组**：
   - 数组预处理（排序、前缀和、逆序处理、差分）；
   - 二分查找（有序数组、最大最小、循环不变量）；
   - 双指针（快慢指针、相向指针）；
   - 滑动窗口；
2. **链表**：
   - 虚拟头节点;
   - 双指针；
3. **字符串**：
   - 字符串预处理（拼接、删减、翻转、扩容）;
   - 双指针;
   - KMP;

## 常用数据结构
1. **哈希表**：
    - 用于查找某个元素是否存在于集合中；
    - 用于统计频率；
    - 难以去重，改用排序+双指针；
    - unordered_map不存在的key的value为0！
    - 能用数组就用数组。
2. **栈**：
   - 用于匹配；
   - 单调栈（用于查找左右第一个最大最小值的位置）；
3. **队列**：
   - 单调队列（用于查找连续范围内的最大最小值）；
   - 优先队列（用于维护前k个最大最小值）；
4. **二叉树**：
   - 思考转换成左子树、右子树的子问题；
   - 主要思考遍历顺序，然后决定写法（递归-后序、回溯-前序、迭代-层序）；
   - 深度遍历（前中后），广度遍历（层序遍历）
   - 二叉树的属性、修改基本都能转换成子树问题靠递归解决
   - 非平衡二叉树的最差复杂度都是O(n)
   - 判断是否为**满二叉树**可以遍历最左和最右节点的深度
   - **完全二叉树**可根据节点的序号可以得到根节点到该节点的路径。
   - **二叉搜索树**：中序遍历是有序数组。
5. **字典树**：
   - 主要用于统计，提高查询效率，避免无谓的字符串比较。
6. **线段树**
7. **堆实现**
8. **并查集**

## 常用算法
1. 双指针
   - 原地修改数组、字符串；
   - 判断是否有环；
2. 递归&迭代
   - 递归三部曲：确定返回值和参数；确定终止条件；确定单层逻辑；
   - 迭代三部曲：初始化栈/队列；while栈/队列不为空；确定循环处理逻辑；（若访问和处理的顺序不同，增加变量用于访问遍历，栈则用于处理遍历）；
   - 深度优先遍历（栈）、广度优先遍历（队列），深度优先遍历（栈）的空间复杂度是递归的深度，广度优先遍历（队列）的复杂度是队列的长度；
   - 用于将问题划分成子问题。
   - 自底向上递归VS自顶向下递归。
   - 只查询单个路径时递归需要返回值。
   - 递归需不需要返回值看是否遍历整棵树和是否需要递归返回值。
3. 回溯：
   - 主要解决组合、排列、分割、子集、棋盘问题；
   - index选取、去重；
   - 去重主要方式：排序、used数组、set
   - 三部曲，考虑要不要排序、去重、从0还是index开始。
   - 是不是同一个集合、可不可重复选取决定了下一个index
   - 子集问题区别在于每个树节点都是答案
   - 排列问题不采用index而是用used判断使用过没，并可直接排序采用used去重
   - 未排序时只能采用set去重
   - 在求和问题中，排序之后加剪枝是常见的套路！
   - 递归回溯不分家；
   - 结果通常保存在全局变量中；参数尽量别带序列式容器，会增加拷贝的时间复杂度和空间复杂度。
   - 回溯前后参数保持不变；
   - 找路径更适合深度优先遍历。

4. 贪心：
   - 局部最优推出全局最优，举不出反例可尝试贪心。
   - 题目通常出现“尽可能”或类似最优的字眼，数据通常是数组或字符串。

5. 动态规划：
   - 三部曲：确定递推式、初始化、确定遍历顺序
   - 动规数组定义要清晰，有争议的下标可以考虑不初始化
   - **01背包和完全背包区别在于是否可重复选取，01背包从后往前遍历，完全背包从前往后。**
   - **组合，可选取的东西为外循环；排列，目标值为外循环；完全背包求最大最小值时与内外循环顺序无关。**
   - 背包问题和回溯问题的相同点：选择
   - 数位DP
   - 考虑多个状态，不要局限于两个状态
   - DP关键在于确定好状态，以及状态间的递推公式（min/max/+/||）
   - DP是自底向上，需要计算所有状态，而记忆化搜索是自顶向下，只需计算最终状态所需的其他状态，避免了无效状态的计算。

## 其他TIPS
### 心态
1. 看清题目！
2. 冷静，确定好取值范围，确定边界情况，分析好各种情况！
3. 循环一定要确定循环条件，索引记得判断是否小于数组长度！
4. if条件要确认好，别随便&&，可能会分类错误！
5. 维护好成员变量，操作后需要修改的变量别忘记！
6. 不必要纠结局部的计算复杂度，编程方便更重要！
7. 不要过于简洁代码，逻辑清晰更重要！
8. 引用符号&别乱用，非特殊不用auto&

### 解题思路
1. **确定变量含义、初始化、遍历顺序！（先左后右、先内后外）**
2. **问题可以转换！（插入变删除、删除变填充等）**
3. 循环问题可以考虑拼接操作

获取数值的二进制位，通过移位并&1即可。

异或操作: **位运算：x & (x-1) 可以去除x最右边的1。**

有除法的地方一定要注意会取整！

二维矩阵存图，可以不用n×n，而是仅存边。

考虑二进制位

去重方法：先排序然后判断 `if (i > 0 && nums[i-1] == nums[i])`

nums.size()返回的是无符号整数，建议先转int。

C++ List底层是链表，增删比vector快

函数对象实现自定义排序：
```c++
class Cmp {
public:
    bool operator() (auto& n1, auto& n2) {
        return ...;
    }
};
```

### 常用库函数
1. `isdigit()`
2. `stoi()`
3. `to_string()`
4. `substr()`
5. `find()`
6. `swap()`
7. `resize()`
8. `reverse()`
9. `sort()`

### 常用头文件
1. `cmath`
2. `<string>`
3. `<iomanip>`
4. `<algorithm>`

# 简洁版
1. 数组、链表、字符串：
   - 预处理（排序、前缀和、差分、虚拟头结点、翻转、拼接、扩容、逆序操作）；
   - 双指针（原地修改、判断环）、滑动窗口；
   - 二分查找（有序数组）；
2. 数据结构：
   - 哈希表（查找、统计频率）；
   - 栈（匹配）；
   - 单调栈（寻找左右第一个最大最小值）；
   - 单调队列（用于查找连续范围内的最大最小值）；
   - 优先队列（用于维护前k个最大最小值）快速选择排序（获取前K个最大最小值）；
   - 二叉树（深度优先遍历or层次遍历）；
     - 判断是否为**满二叉树**可以遍历最左和最右节点的深度
     - **完全二叉树**可根据节点的序号可以得到根节点到该节点的路径。
     - **二叉搜索树**：中序遍历是有序数组。
3. 高级数据结构：
   - 字典树（快速判断单词是否存在于集合内）
   - 线段树（用于维护连续子区间的信息）
   - 并查集（判断两个元素是否处于同一个集合）、带权并查集
   - 树状数组(add和preSum，用于修改和计算数组前缀和)
4. 方法：
   - 递归&迭代&回溯（深度优先遍历、广度优先遍历）（组合VS排列VS子集，去重：排序+used vs set）
   - 贪心（题目通常出现“尽可能”或类似最优的字眼，局部最优推出全局最优）
   - 动态规划（和回溯类似，选择问题可以转换成背包问题。01背包VS完全背包，组合VS排列）
   - 图论（dfs适合搜索路径、bfs适合最短路径、拓扑排序、最小生成树、最短路径743、二分图785）
   - 十大排序(快速选择算法)
5. 特殊：
   - 位运算；
   - 分治（O(N)时间求第K大的数）；
   - 数论；
   - 海量数据处理；

### Tips
1. 冷静！细心！看清题目和提示！
2. 想想题目考点在哪，模拟是例外。
3. 多举例，完善各种分类情况。
4. 写的过程不求代码简洁，只求逻辑清晰准确。
5. 相信自己。
6. 二叉树薄弱点
7. 可以修改原数组吗？不确定或不清楚的问面试官。
8. 优先队列写法复习一下
9. 考虑边界、数据溢出的问题。
10. 2的次方可以改为移位操作。

# 三刷
**解题三要数：预处理 + 数据结构 + 算法**
**常用方法：前缀和、排序、双指针、二分查找 + 哈希表、栈、队列**
**二分+贪心**
**前缀和+哈希表**

难点：
1. 有序数组的平方（逆序处理）；
2. 重复的子字符串（拼接处理）；
3. 完全二叉树的节点数；
4. 平衡二叉树（想清楚递归和迭代哪个适合）；
5. 左叶子之和（对于当前节点求它的左叶子节点之和，而非判断当前节点是不是左叶子）；
6. 中序遍历和前（后）序遍历构造二叉树
7. **最大二叉树（单调栈）**
8. 二叉搜索树的增删改(讨论好分类情况)
9.  贪心（摆动序列、跳跃游戏2、**分发糖果**）
10. 动态规划（最长上升子序列、单词拆分）
11. 并查集（**冗余连接2**）
12. **求最大最小值，可以判断某个值是否符合条件（经典有序二分）**
13. **快速选择算法**

hot100:
1. 寻找两个正序数组的中位数
2. 正则表达式匹配
3. 盛最多容器的水
4. **最长有效括号**
5. **二叉树展开为链表**
6. 最长子序列
7. LRU缓存
8. 最小栈
9. **寻找重复数**
10. 戳气球
11. **路径总和三**
12. 找到数组中所有消失的数字
13. 和为k的子数组

ACM:
1. 层序遍历输入二叉树，先构造节点数组，然后根据2*index+1/2指向自己的孩子。


红黑树
智能指针
B树和B+树